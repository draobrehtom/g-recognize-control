package com.example.draobrehtom.gesturerecognizecontrol;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;
import org.opencv.core.Core;
import org.opencv.core.Core.MinMaxLocResult;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;
import org.opencv.android.CameraBridgeViewBase;
import org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;
import org.opencv.video.BackgroundSubtractor;
import org.opencv.video.BackgroundSubtractorKNN;
import org.opencv.video.BackgroundSubtractorMOG2;
import org.opencv.video.Video;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.SurfaceView;
import android.view.View;
import android.view.WindowManager;
import android.view.View.OnTouchListener;
import android.widget.Toast;

import static org.opencv.imgproc.Imgproc.ADAPTIVE_THRESH_MEAN_C;
import static org.opencv.imgproc.Imgproc.THRESH_BINARY;

public class HandTrackingActivity extends Activity implements OnTouchListener, CvCameraViewListener2 {
    private static final String TAG = "OCVSample::Activity";
    private int Height = 400;
    private int Width  = 600;

    private final double alpha = 2.0;
    private final double beta = 0.0;

    private final int KERNEL_SIZE = 5;
    Mat kernel;
    private Scalar CONTOUR_COLOR;

    private CameraBridgeViewBase mOpenCvCameraView;

    public boolean haveRange = false;
    Mat mRgba;
    Mat mHsv;
    Mat threshold;
    Mat mHierarchy;

    // Own implementation
    Mat frame;




    // TCP-IP
    // Implementation

    public static String currentIP= "10.0.109.99";
    public static int    currentPort = 4567;

    //define callback function
    public void tcpHandler(String ip, int port, String query, Client.MyCallbackInterface callback) {
        new Client(ip, port, query, callback).execute();
    }

    public void sendToServer(String message) {
        Log.i(TAG, "BEGIN sendToServer");
        if (message == "right" || message == "left") {
            Log.i(TAG, "IF sendToServer");
            tcpHandler(MainActivity.currentIP, MainActivity.currentPort, message, new Client.MyCallbackInterface() {
                @Override
                public void tcpHandler(String response) {
                    Log.i(TAG, "SERVER: " + response);
                }
            });
        }
    }

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        Log.i(TAG, "called onCreate");

        super.onCreate(savedInstanceState);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        setContentView(R.layout.activity_hand_tracking);

        currentIP = MainActivity.currentIP;
        currentPort = MainActivity.currentPort;

        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.handtracking_activity_java_surface_view);

        mOpenCvCameraView.setMaxFrameSize(Height, Width);
        mOpenCvCameraView.disableView();
        mOpenCvCameraView.enableView();

        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);
        mOpenCvCameraView.setCvCameraViewListener(this);
        mOpenCvCameraView.setOnTouchListener(HandTrackingActivity.this);
        mOpenCvCameraView.setFocusable(false);
    }

    public void onCameraViewStarted(int width, int height) {
        Log.i(TAG, "-----------Widht: " +width+" Height: "+height);
        Height = height;
        Width = width;
        mRgba = new Mat(height, width, CvType.CV_8UC3);
        mHsv = new Mat(); //(height, width, CvType.CV_8UC3);
        threshold = new Mat(); //(height, width, CvType.CV_8UC3);
        kernel = Mat.zeros(KERNEL_SIZE, KERNEL_SIZE, CvType.CV_8UC1);
        CONTOUR_COLOR = new Scalar(255,0,0);
        mHierarchy = new Mat();

    }

    public void onCameraViewStopped() {
    }

    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    BackgroundSubtractorMOG2 pMOG2 = Video.createBackgroundSubtractorMOG2();
    List<MatOfPoint> contours;
    Mat hierarchy;
    Size size1 = new Size(3,3);

    Mat leftROI;
    Mat rightROI;
    List<MatOfPoint> lcontours;
    List<MatOfPoint> rcontours;
    Mat lhierarchy;
    Mat rhierarchy;
    String messageDisplay = "Start";
    Rect lroi = new Rect(0,0,384,288);
    Rect rroi = new Rect(0,0,384,288);
    int roiH, roiW = 0;


    int frameCounter = 0;
    int decisionPriority = 0;
    boolean isReadyToAcceptDecision = false;
    String warningMessage = "Keep phone statically";
    String preWaitingMessage = "Calibration...";
    String actionMessage = "Place hand";
    String waitingMessage = "Hold you hand...";
    String coverMessage = "Cover hand, choice made";
    String displayMessage = warningMessage;

    public String makeDecision(String message) {
        if (message == "undefined" && !isReadyToAcceptDecision) {
            decisionPriority++;
            if (decisionPriority > 2) {
                decisionPriority = 0;
                isReadyToAcceptDecision = true;
                displayMessage = actionMessage;
            } else {
                displayMessage = preWaitingMessage;
            }
        } else if (isReadyToAcceptDecision) {
            if (message == "left" || message == "right") {
                decisionPriority++;
                if (decisionPriority > 1) {
                    decisionPriority = 0;
                    displayMessage = coverMessage + " " + message;
                    isReadyToAcceptDecision = false;
                    return message;
                } else {
                    displayMessage = waitingMessage;
                }

            } else {
                displayMessage = actionMessage;
            }

        } else {
            displayMessage = warningMessage;
        }
        return "undefined";
    }

    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {
        frameCounter++;
        if (frameCounter >+ 25) {
            frameCounter = 0;
        }
        frame = inputFrame.gray();
        Imgproc.cvtColor(frame, mRgba, Imgproc.COLOR_GRAY2RGB);
        Imgproc.blur(mRgba, mRgba, size1);
        Core.flip(mRgba, mRgba, 1);

        if (roiW == 0) {
            // get mat size
            roiH = (int) mRgba.size().height;
            roiW = (int) mRgba.size().width;
            // set left roi
            lroi.height = roiH;
            lroi.width = roiW/2;
            // set right roi
            rroi.x = roiW/2;
            rroi.height = roiH;
            rroi.width = roiW/2;
        }

        if (haveRange) {
            pMOG2.apply(mRgba, fgMaskMOG2);
            Imgproc.erode(fgMaskMOG2, fgMaskMOG2, new Mat());
            Imgproc.dilate(fgMaskMOG2, fgMaskMOG2, new Mat());

            // TODO: Find contours in left and right area and compare per amount
            leftROI =  fgMaskMOG2.submat(lroi);
            rightROI = fgMaskMOG2.submat(rroi);

//             Test rectangles
            Imgproc.rectangle(fgMaskMOG2, new Point(0, 0), new Point(Width/2, Height), new Scalar(255, 0, 0, 255), 3);
            Imgproc.rectangle(fgMaskMOG2, new Point(Width/2, 0), new Point(Width, Height), new Scalar(255, 0, 0, 255), 3);

            lcontours = new ArrayList<MatOfPoint>();
            lhierarchy = new Mat();
            Imgproc.findContours(leftROI, lcontours, lhierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE, new Point(0, 0));
            lhierarchy.release();

            rcontours = new ArrayList<MatOfPoint>();
            rhierarchy = new Mat();
            Imgproc.findContours(rightROI, rcontours, rhierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE, new Point(0, 0));
            rhierarchy.release();


            if (lcontours.size() > rcontours.size()) {
                messageDisplay = "left";
            } else if (lcontours.size() < rcontours.size()) {
                messageDisplay = "right";
            } else {
                messageDisplay = "undefined";
            }

            if (frameCounter == 12) {
                Log.i(TAG, messageDisplay);
                messageDisplay = makeDecision(messageDisplay);
                sendToServer(messageDisplay);
                Log.i(TAG, "JEST");
            }

            //sendToServer(messageDisplay);


            contours = new ArrayList<MatOfPoint>();
            hierarchy = new Mat();

            Imgproc.findContours(fgMaskMOG2, contours, hierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE, new Point(0, 0));
            hierarchy.release();
            Imgproc.drawContours(fgMaskMOG2, contours, -1, new Scalar(Math.random()*255, Math.random()*255, Math.random()*255));//, 2, 8, hierarchy, 0, new Point());

        } else {
            fgMaskMOG2 = mRgba;
        }
        if (!haveRange) {
            displayMessage = "Touch the screen";
        }
        Imgproc.putText(fgMaskMOG2, displayMessage, new Point(fgMaskMOG2.cols()*0.1, fgMaskMOG2.rows()*0.9),
                Core.FONT_HERSHEY_SIMPLEX, 0.7, new Scalar(255, 0, 0), 2);
        return fgMaskMOG2;
    }


    @Override
    public boolean onTouch(View v, MotionEvent event) {
        if(haveRange) {
            haveRange=false;
            return false;
        }
        haveRange = true;

        Log.i(TAG, "Captured frame");
        return false;
    }


    /***************************************************************************
     * *************************************************************************/
    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
        @Override
        public void onManagerConnected(int status) {
            switch (status) {
                case LoaderCallbackInterface.SUCCESS:
                {
                    Log.i(TAG, "OpenCV loaded successfully");
                    mOpenCvCameraView.enableView();
                } break;
                default:
                {
                    super.onManagerConnected(status);
                } break;
            }
        }
    };


    @Override
    public void onPause()
    {
        super.onPause();
        if (mOpenCvCameraView != null)
            mOpenCvCameraView.disableView();
    }

    @Override
    public void onResume()
    {
        super.onResume();
        OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_3, this, mLoaderCallback);
    }

    public void onDestroy() {
        super.onDestroy();
        if (mOpenCvCameraView != null)
            mOpenCvCameraView.disableView();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        return true;
    }

}
